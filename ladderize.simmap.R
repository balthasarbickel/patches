# phytools::ladderize.simmap is not compatible with source_url('https://github.com/IVS-UZH/phylo-convert/raw/master/graft.R') because ladderize.simmap relies on ape::extract.clade as part of the utility function matchNodes and extract.clade throws an error under certain (ill-understood) conditions generated by graft. The problem is solved here by using phangorn::Descendants instead, which is much more robust. [2016-11-29 BB] 

ladderize.simmap<-function(tree,right=TRUE){
	if(!inherits(tree,"phylo")) stop("tree should be an object of class \"phylo\".")
	obj<-read.tree(text=write.tree(ladderize(tree,right=right)))
	rN<-Ntip(obj)+1
	T<-cbind(1:Ntip(obj),sapply(obj$tip.label,function(x,y) which(y==x),y=tree$tip.label))
	N<-matchNodes(obj,tree)
	M<-rbind(T,N[N[,1]!=rN,])
	ii<-sapply(M[,1],function(x,y) which(y==x),y=obj$edge[,2])
	jj<-sapply(M[,2],function(x,y) which(y==x),y=tree$edge[,2])
	obj$maps<-vector(length=nrow(tree$edge),mode="list")
	obj$mapped.edge<-matrix(NA,nrow(tree$edge),ncol(tree$mapped.edge),
		dimnames=list(apply(tree$edge,1,paste,collapse=","),
		colnames(tree$mapped.edge)))
	if(!is.null(tree$states))
		obj$states<-tree$states[sapply(obj$tip.label,function(x,y) which(y==x),y=tree$tip.label)]
	if(!is.null(tree$node.states)) obj$node.states<-matrix(NA,nrow(tree$edge),2)
	for(i in 1:length(ii)){
		obj$maps[[ii[i]]]<-tree$maps[[jj[i]]]
		obj$mapped.edge[ii[i],]<-tree$mapped.edge[jj[i],]
		if(!is.null(tree$node.states)) obj$node.states[ii[i],]<-tree$node.states[jj[i],]
	}
	obj
}

matchNodes<-function(tr1,tr2,method=c("descendants","distances"),...){
	require(phangorn)
	if(!inherits(tr1,"phylo")||!inherits(tr1,"phylo")) stop("tr1 & tr2 should both be objects of class \"phylo\".")
	if(hasArg(quiet)) quiet<-list(...)$quiet
	else quiet<-FALSE
	method<-method[1]
	method<-matchType(method,c("descendants","distances"))
	if(method=="descendants"){
		# desc.tr1<-lapply(1:tr1$Nnode+length(tr1$tip),function(x) extract.clade(tr1,x)$tip.label)
		desc.tr1<-lapply(1:tr1$Nnode+length(tr1$tip),function(x) tr1$tip.label[unlist(Descendants(tr1, x, type="tips"))])
		names(desc.tr1)<-1:tr1$Nnode+length(tr1$tip)
		# desc.tr2<-lapply(1:tr2$Nnode+length(tr2$tip),function(x) extract.clade(tr2,x)$tip.label)
		desc.tr2<-lapply(1:tr2$Nnode+length(tr2$tip),function(x) tr2$tip.label[unlist(Descendants(tr2, x, type="tips"))])
		names(desc.tr2)<-1:tr2$Nnode+length(tr2$tip)
		Nodes<-matrix(NA,length(desc.tr1),2,dimnames=list(NULL,c("tr1","tr2")))
		for(i in 1:length(desc.tr1)){
			Nodes[i,1]<-as.numeric(names(desc.tr1)[i])
			for(j in 1:length(desc.tr2))
				if(all(desc.tr1[[i]]%in%desc.tr2[[j]])&&all(desc.tr2[[j]]%in%desc.tr1[[i]]))
					Nodes[i,2]<-as.numeric(names(desc.tr2)[j])
		}
	} else if(method=="distances"){
		if(hasArg(tol)) tol<-list(...)$tol
		else tol<-1e-6
		if(hasArg(corr)) corr<-list(...)$corr
		else corr<-FALSE
		if(corr) tr1$edge.length<-tr1$edge.length/max(nodeHeights(tr1))
		if(corr) tr2$edge.length<-tr2$edge.length/max(nodeHeights(tr2))
		D1<-dist.nodes(tr1)[1:length(tr1$tip),1:tr1$Nnode+length(tr1$tip)]
		D2<-dist.nodes(tr2)[1:length(tr2$tip),1:tr2$Nnode+length(tr2$tip)]
		rownames(D1)<-tr1$tip.label
		rownames(D2)<-tr2$tip.label
		common.tips<-intersect(tr1$tip.label,tr2$tip.label)
		D1<-D1[common.tips,]
		D2<-D2[common.tips,]
		Nodes<-matrix(NA,tr1$Nnode,2,dimnames=list(NULL,c("tr1","tr2")))
		for(i in 1:tr1$Nnode){
			if(corr) z<-apply(D2,2,function(X,y) cor(X,y),y=D1[,i])
			else z<-apply(D2,2,function(X,y) 1-sum(abs(X-y)),y=D1[,i])
			Nodes[i,1]<-as.numeric(colnames(D1)[i])
			if(any(z>=(1-tol))){
				a<-as.numeric(names(which(z>=(1-tol))))
				if(length(a)==1) Nodes[i,2]<-a
				else {
					Nodes[i,2]<-a[1]
					if(!quiet) warning("polytomy detected; some node matches may be arbitrary")
				}
			}
		}
	}
	return(Nodes)
}

matchType<-function(type,types){
	for(i in 1:length(types))
		if(all(strsplit(type,split="")[[1]]==strsplit(types[i],split="")[[1]][1:length(strsplit(type,split="")[[1]])]))
			type=types[i]
	return(type)
}
